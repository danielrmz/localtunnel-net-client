/*
Copyright (C) 2011 by Daniel Ramirez (hello@danielrmz.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

namespace LocalTunnel.Library
{
    using Renci.SshNet;
    using Renci.SshNet.Common;
    using Dex.Utilities;
    using LocalTunnel.Library.Models;
    using LocalTunnel.Library.Exceptions;
    using System.Net.Sockets;

    /// <summary>
    /// Core class for Localtunnel service.
    /// Based on the Ruby client implementation.
    /// </summary>
    public class Tunnel
    {
        #region Properties

        /// <summary>
        /// Service host, the gateway between your machine and the world. 
        /// Defaults to open.localtunnel.com
        /// </summary>
        public string ServiceHost
        {
            get { return _serviceHost; }
            set { _serviceHost = value; }
        }

        /// <summary>
        /// The host generated by localtunnel
        /// </summary>
        public string TunnelHost
        {
            get
            {
                if (_config == null)
                {
                    return string.Empty;
                }
                return _config.host;
            }
        }

        /// <summary>
        /// Date the tunnel was created
        /// </summary>
        public DateTime Created { get; private set; }

        /// <summary>
        /// Port to be exposed, between 1 and 65535
        /// </summary>
        public int LocalPort { 
            get {
                return _localPort;
            }
            private set
            {
                if (value <= 0 || value > 65535)
                {
                    throw new ServiceException("Invalid Port Number, must be between 1 and 65535");
                }
                _localPort = value;
            }
        }
        private int _localPort;

        /// <summary>
        /// Specific localhost to listen to
        /// </summary>
        public string LocalHost
        {
            get
            {
                return _localHost;
            }
            private set
            {
                if (string.IsNullOrEmpty(value))
                {
                    throw new ServiceException("Invalid local hostname");
                }
                _localHost = value;
            }
        }
        private string _localHost;

        /// <summary>
        /// Public Key file path
        /// </summary>
        public string PublicKeyFile { 
            get {
                return _publicKeyFile;
            }
            private set
            {
                if (!File.Exists(value))
                {
                    throw new FileNotFoundException("Public key file not found");
                }
                _publicKeyFile = value;
            }
        }
        private string _publicKeyFile;

        /// <summary>
        /// Private key filepath
        /// </summary>
        public string PrivateKeyFile
        {
            get
            {
                return _privateKeyFile;
            }
            private set
            {
                if (!File.Exists(value))
                {
                    throw new FileNotFoundException("Private key file not found", _privateKeyFile);
                }

                _privateKeyFile = value;
            }
        }
        private string _privateKeyFile;

        /// <summary>
        /// Private key filepath
        /// </summary>
        public string PrivateKey
        {
            get
            {
                if(!string.IsNullOrEmpty(this.PrivateKeyFile)) 
                {
                    return File.ReadAllText(this.PrivateKeyFile);
                }
                if (!string.IsNullOrEmpty(_privateKey))
                {
                    return _privateKey;
                }
                throw new ServiceException("Public key not set");
            }
            set
            {
                _privateKey = value;
            }
        }
        private string _privateKey;

        /// <summary>
        /// The contents of the public key
        /// </summary>
        public string PublicKey { 
            get {
                if (!string.IsNullOrEmpty(this.PublicKeyFile))
                {
                    return File.ReadAllText(this.PublicKeyFile);
                }
                if (!string.IsNullOrEmpty(_publicKey))
                {
                    return _publicKey;
                }
                throw new ServiceException("Public key not set");
            }
            set
            {
                _publicKey = value;
            }
        }
        private string _publicKey;

        /// <summary>
        /// Gets if the client is online or not.
        /// </summary>
        public bool IsConnected
        {
            get
            {
                return (this._client != null && this._client.IsConnected);
            }
        }

        /// <summary>
        /// Determines if the tunnel has been stopped or not.
        /// </summary>
        public bool IsStopped { get; private set; }

        /// <summary>
        /// Configuration obtained through a first request to the service.
        /// </summary>
        private ConfigurationResponse _config;

        /// <summary>
        /// Service host
        /// </summary>
        private string _serviceHost = "open.localtunnel.com";

        /// <summary>
        /// SSH.net client
        /// </summary>
        private SshClient _client;

        /// <summary>
        /// Forwarded port
        /// </summary>
        private ForwardedPortRemote _connectionPort;


        #endregion

        #region Constructors

        /// <summary>
        /// Simple constructor, key pairs are generated automatically. 
        /// If the app that uses the library requires to save the keys, 
        /// they will be accessible through PublicKey/PrivateKey properties.
        /// </summary>
        /// <param name="localHost"></param>
        /// <param name="localPort"></param>
        public Tunnel(string localHost, int localPort) 
        {
            this.LocalHost = localHost;
            this.LocalPort = localPort;

            // Generate in-memory keys for use.
            string comment = string.Format("localtunnel-{0}", (int)((DateTime.Now - new DateTime(1970, 1, 1).ToLocalTime()).TotalSeconds));
            Dex.Utilities.Cyrpto.RsaKeyPair key = Dex.Utilities.Cyrpto.GenerateRsaKeyPair(2048, comment);

            this.PublicKey = key.PublicSSHKey;
            this.PrivateKey = key.PrivateKeyAsPEM;
        }

        /// <summary>
        /// Constructor which defaults local listening host to 127.0.0.1
        /// </summary>
        /// <param name="localPort"></param>
        public Tunnel(int localPort) 
            : this("127.0.0.1", localPort)
        {   
        }

        /// <summary>
        /// Constructor that gets the the private key file path,
        /// internally it obtains the public key to set it to the server.
        /// </summary>
        /// <param name="localHost">Host to be forwarded</param>
        /// <param name="localPort">Port to be forwarded</param>
        /// <param name="publicKeyFile">Key to add to LocalTunnel's service</param>
        public Tunnel(string localHost, int localPort, string privateKeyFile)
        {
            this.LocalHost = localHost;
            this.LocalPort = localPort;
            this.PrivateKeyFile = privateKeyFile;

            // Obtain public from private and write it to the same folder.
            string comment = string.Format("localtunnel-{0}", (int)((DateTime.Now - new DateTime(1970, 1, 1).ToLocalTime()).TotalSeconds));
            
            Dex.Utilities.Cyrpto.WriteRsaKeyPair(this.PrivateKeyFile, comment);
            this.PublicKeyFile = string.Format("{0}.pub", this.PrivateKeyFile);
        }

        /// <summary>
        /// Constructor which defaults the localhost to 127.0.0.1
        /// It only accepts the private key file, the public key is generated
        /// based on this one. 
        /// </summary>
        /// <param name="localPort"></param>
        /// <param name="privateKeyFile"></param>
        public Tunnel(int localPort, string privateKeyFile)
            : this("127.0.0.1", localPort, privateKeyFile)
        {
        }

        /// <summary>
        /// Constructor that specifies both keys.
        /// </summary>
        /// <param name="localPort">Port to be forwarded</param>
        /// <param name="publicKeyFile">Key to add to LocalTunnel's service</param>
        /// <param name="privateKeyFile">Private key used when creating the tunnel via ssh to the service.</param>
        public Tunnel(string localHost, int localPort, string publicKeyFile, string privateKeyFile)
        {
            this.LocalHost = localHost;
            this.LocalPort = localPort;
            this.PublicKeyFile  = publicKeyFile;
            this.PrivateKeyFile = privateKeyFile;
        }

        /// <summary>
        /// Constructor which default the local host to 127.0.0.1, 
        /// Accepts both keys to be used.
        /// </summary>
        /// <param name="localPort"></param>
        /// <param name="publicKeyFile"></param>
        /// <param name="privateKeyFile"></param>
        public Tunnel(int localPort, string publicKeyFile, string privateKeyFile)
            : this("127.0.0.1", localPort, publicKeyFile, privateKeyFile)
        {   
        }

        #endregion

        #region Core client methods

        /// <summary>
        /// Creates the connection.
        /// </summary>
        /// <returns></returns>
        public Tunnel Execute()
        {
            RegisterTunnel();
            StartTunnel();

            return this;
        }

        /// <summary>
        /// Stops the local tunnel.
        /// </summary>
        public void StopTunnel()
        {
            if (_client != null && _client.IsConnected)
            {
                _client.Disconnect();
                _client.Dispose();
                _client = null;
                this.IsStopped = true;
            }
        }

        /// <summary>
        /// Reopens tunnel
        /// </summary>
        public void ReOpenTunnel()
        {
            if (this.IsStopped && !this.IsConnected)
            {
                this.StartTunnel();
            }
        }

        /// <summary>
        /// Registers a tunnel, meaning creating a request to localtunnel to open up a subdomain and port to bridge to.
        /// </summary>
        private void RegisterTunnel()
        {
            string url = string.Format("http://{0}/", ServiceHost);

            try
            {
                _config = Web.DoPost<ConfigurationResponse>(url, new Dictionary<string, string>() { { "key", PublicKey } });

                if (!string.IsNullOrEmpty(_config.error))
                {
                    throw new ServiceException(_config.error);
                }
            }
            catch (ArgumentException ae)
            {
                throw new ServiceException("Invalid server response: " + ae.Message);
            }

            Created =  DateTime.Now;

            // Record the usage of the port.
            Port.AddUsage(LocalHost, LocalPort, ServiceHost);
        }

        /// <summary>
        /// Starts the ssh connection, and bridge the streams.
        /// </summary>
        private void StartTunnel()
        {
            try
            {
                _client = new SshClient(_config.host, _config.user, new PrivateKeyFile(new MemoryStream(Encoding.Default.GetBytes(PrivateKey))));
                _client.Connect();
                _client.KeepAliveInterval = new TimeSpan(0, 0, 5);
                
                if (!_client.IsConnected)
                {
                    throw new ServiceException("Can't start tunnel, try again.");
                }

                string connectHost = string.IsNullOrEmpty(this.LocalHost) ? "127.0.0.1" : this.LocalHost;

                _connectionPort = new ForwardedPortRemote((uint)_config.through_port, connectHost, (uint)LocalPort);

                _connectionPort.Exception += new EventHandler<ExceptionEventArgs>(fw_Exception);
                _connectionPort.RequestReceived += new EventHandler<PortForwardEventArgs>(port_RequestReceived);
                _client.AddForwardedPort(_connectionPort);
                
                _connectionPort.Start();
            }
            catch (Exception e)
            {
                throw new ServiceException(e.Message);
            }


        }

        public delegate void EventSocketException(Tunnel t, string e);

        public EventSocketException OnSocketException { get; set;}

        /// <summary>
        /// Calls delegate events if some exception occured with the tunnel.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void fw_Exception(object sender, ExceptionEventArgs e)
        {
            if (e.Exception is SocketException)
            {
                if (OnSocketException != null)
                {
                    this.IsStopped = true;
                    OnSocketException(this, e.Exception.Message);
                }
            }
            
        }

        /// <summary>
        /// Handle some tunnel request.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void port_RequestReceived(object sender, PortForwardEventArgs e)
        {
            // We could keep a record of connections 
        }

        #endregion
       
    }
}
